# End-to-End Tests

The end-to-end tests use Puppeteer and Jest to connect to a running instance of the application and use it through a browser like a normal user would.

## Installation
```bash
cd test
yarn install
```

Puppeteer includes a bundled Chromium executable, but not all the various Chrome dependencies.
This is not generally an issue in development environments where Chrome is already installed.
Be aware of this when setting up CI or Docker images though.

## Running Tests
You will need a running instance of the app, both the `web` and `girder` components.
Assuming the web app is running at `http://localhost:8085`:
```bash
# within "test"
CLIENT_URL=http://localhost:8085 yarn run test
```

## Debugging Tests
Frequently when writing tests, they will not work the first time.
For browser based tests, it is very helpful to be able to see the state of the browser at the point of failure.
Use this command to run the browser in headful mode and extend the Jest test timeout to 1 hour:
```bash
# within "test"
CLIENT_URL=http://localhost:8085 yarn run test-debug
```
You can also include `await jestPuppeteer.debug();` at any point in the test to create a manual breakpoint.

## Writing Tests

### BDD
Jest encourages BDD testing syntax.
All tests should be formatted roughly like this:
```javascript
describe('thing being tested', () => {
  it('should behave like this', async () => {
    // ... test steps ...
  });
  it('does the right thing', async () => {
    // ... test steps ...
  });
});
```

### expect-puppeteer
Puppeteer provides several very useful integrations with Jest, including the `expect-puppeteer` library.
It registers several new methods on the Jest `expect` object to provide common browser operations.
For example:
```javascript
await expect(page).toFill('input#username', 'DandiDan');
await expect(page).toClick('input#submit`);
```

### jest-xpaths
Puppeteer and `expect-puppeteer` prefer using CSS selectors whenever possible.
They do have some support for XPath locators, but they cannot be used for everything that CSS selectors can be used for.
Sadly, many elements generated by Vuetify cannot practically be identified with CSS selectors, so sometimes XPaths are required.
To help remedy this, the `jest-xpaths` module registers several new methods on the Jest `expect` object.
For instance:
```javascript
await expect(page).toFillXPath('//input[@id="username"]', 'DandiDan');
await expect(page).toClickXPath('//input[@id="submit"]');
```
This module is still a work in progress.
If you think it should be capable of something that it doesn't do yet, feel free to augment it.

### vuetify-xpaths
Despite XPaths sometimes being the only option for locating Vuetify elements, they can still be painful to write and maintain.
To help with this, we have the `vuetify-xpaths` helper which generates XPaths (element locators) for common Vuetify elements.
For example, to fill a text field labelled `Username` and click a button labelled `Submit`, you can do this:
```javascript
await expect(page).toFillXPath(vTextField('Username'), 'DandiDan');
await expect(page).toClickXPath(vBtn('Submit'));
```
#### Usage
The first argument to any `vElement` will generally be the expected contents of the `v-element`.
* If contents is falsy, like `vFoo()`, the XPath will match any `v-foo`.
* If contents is a string, like `vFoo('contents')`, the XPath will match any `v-foo` which contains the text `contents`.
* If contents is a valid XPath, like `vFoo(vBar())`, the XPath will match any `v-foo` which contains a `v-bar`.
Note that `vBar` is not necessarily an immediate child of `vFoo`; `vFoo(vBar())` will also match `<v-foo><div><v-bar /></div></v-foo>`.

The second argument will generally be an object whose options will vary based on the element.
Most elements have a `cssClass` option which will only match elements with the given class.
* If `cssClass` is falsy, nothing will be done.
* If `cssClass` is a string, like `vFoo(null, 'text-center')`, it will match all `v-foo` which have the class `text-center`.
This is roughly equivalent to the CSS selector `.v-foo.text-center`.
* If `cssClass` is an array, like `vFoo(null, ['text-center', 'text--blue'])`, it will match all `v-foo` which have both classes `text-center` and `text--blue`.
This is roughly equivalent to the CSS selector `.v-foo.text-center.text--blue`.

Other secondary options will generally behave like `contents` or like `cssClass`, depending on whether they identify DOM properties or CSS classes.

Because generated XPaths are strings, generally speaking they can be composed with string concatenation.
`vFoo() + vBar()` will match any `v-bar` which is contained in a `v-foo`.

This module is still a work in progress.
It relies on the internal behavior of Vuetify and is liable to break with any Vuetify update.
If existing methods don't work in your use case or there is a missing method, feel free to fix it.
