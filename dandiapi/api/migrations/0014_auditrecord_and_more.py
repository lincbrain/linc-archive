# Generated by Django 4.2.17 on 2024-12-10 14:30

from django.db import migrations, models
from django.db.models.expressions import RawSQL

def remove_access_fields(apps, _):
    Asset = apps.get_model('api.Asset')
    AuditRecord = apps.get_model('api.AuditRecord')

    # Use the postgres jsonb '-' operator to delete the 'access' field from metadata
    Asset.objects.filter(published=False, metadata__access__isnull=False).update(
        metadata=RawSQL("metadata - 'access'", [])
    )

    # Delete access field from existing audit records
    # https://www.postgresql.org/docs/current/functions-json.html#:~:text=jsonb%20%23%2D%20text%5B%5D%20%E2%86%92%20jsonb
    AuditRecord.objects.filter(record_type__in=['add_asset', 'update_asset']).update(
        details=RawSQL("details #- '{metadata, access}'", [])
    )

def migrate_embargoed_asset_blobs(apps, _):
    Asset = apps.get_model('api.Asset')
    AssetBlob = apps.get_model('api.AssetBlob')
    EmbargoedAssetBlob = apps.get_model('api.EmbargoedAssetBlob')

    def migrate_embargoed_blob(embargoed_blob):
        # Check if the blob we care about already exists (possibly under a different blob_id due to
        # de-duplication).
        # This will handle the following cases:
        #   1. This asset is part of an "asset chain", where multiple assets point to the same blob
        #   2. This blob this asset points to exists across multiple embargoed dandisets under
        #       different blob_ids, due to the lack of cross-dandiset embargo de-duplication.
        #   3. This blob this asset points to already exists as a normal AssetBlob, due to the lack
        #       of de-duplication between open and embargoed dandisets. This is essentially the same
        #       as the above case, but between an embargoed and open dandiset, instead of two
        #       embargoed dandisets.
        #
        # In case #3, the asset will effectively be unembargoed.
        existing_blob = AssetBlob.objects.filter(
            etag=embargoed_blob.etag, size=embargoed_blob.size
        ).first()
        if existing_blob:
            existing_blob.download_count += embargoed_blob.download_count
            existing_blob.save()
            return existing_blob

        blob_id = str(embargoed_blob.blob_id)
        new_blob_location = f'blobs/{blob_id[0:3]}/{blob_id[3:6]}/{blob_id}'
        return AssetBlob.objects.create(
            embargoed=True,
            blob=new_blob_location,
            blob_id=embargoed_blob.blob_id,
            created=embargoed_blob.created,
            modified=embargoed_blob.modified,
            sha256=embargoed_blob.sha256,
            etag=embargoed_blob.etag,
            size=embargoed_blob.size,
            download_count=embargoed_blob.download_count,
        )

    # For each relevant asset, create a new asset blob with embargoed=True,
    # and point the asset to that
    embargoed_assets = Asset.objects.filter(embargoed_blob__isnull=False).select_related(
        'embargoed_blob'
    )
    for asset in embargoed_assets.iterator():
        asset.blob = migrate_embargoed_blob(asset.embargoed_blob)
        asset.embargoed_blob = None
        asset.save()
    assert not Asset.objects.filter(embargoed_blob__isnull=False).exists()  # noqa: S101

    # Finally, handle orphaned EmbargoedAssetBlobs. Since we've already taken care of all assets
    # that point to embargoed blobs, we can migrate the remaining embargoed blobs without issue.
    embargoed_blobs = EmbargoedAssetBlob.objects.iterator()
    for embargoed_blob in embargoed_blobs:
        migrate_embargoed_blob(embargoed_blob)

class Migration(migrations.Migration):

    dependencies = [
        ('api', '0013_remove_webknossosannotation_asset'),
    ]

    operations = [
        migrations.CreateModel(
            name='AuditRecord',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('timestamp', models.DateTimeField(auto_now_add=True)),
                ('dandiset_id', models.IntegerField()),
                ('username', models.CharField(max_length=39)),
                ('user_email', models.CharField(max_length=254)),
                ('user_fullname', models.CharField(max_length=301)),
                ('record_type', models.CharField(choices=[('create_dandiset', 'create_dandiset'), ('change_owners', 'change_owners'), ('update_metadata', 'update_metadata'), ('add_asset', 'add_asset'), ('update_asset', 'update_asset'), ('remove_asset', 'remove_asset'), ('create_zarr', 'create_zarr'), ('upload_zarr_chunks', 'upload_zarr_chunks'), ('delete_zarr_chunks', 'delete_zarr_chunks'), ('finalize_zarr', 'finalize_zarr'), ('unembargo_dandiset', 'unembargo_dandiset'), ('publish_dandiset', 'publish_dandiset'), ('delete_dandiset', 'delete_dandiset')], max_length=32)),
                ('details', models.JSONField(blank=True)),
            ],
        ),
        migrations.RunPython(remove_access_fields),
        migrations.RemoveConstraint(
            model_name='asset',
            name='asset_metadata_no_computed_keys_or_published',
        ),
        migrations.RemoveConstraint(
            model_name='assetpath',
            name='consistent-slash',
        ),
        migrations.RemoveField(
            model_name='asset',
            name='previous',
        ),
        migrations.AddConstraint(
            model_name='asset',
            constraint=models.CheckConstraint(check=models.Q(models.Q(('published', False), models.Q(('metadata__has_any_keys', ['id', 'access', 'path', 'identifier', 'contentUrl', 'contentSize', 'digest', 'datePublished', 'publishedBy']), _negated=True)), models.Q(('published', True), ('metadata__has_keys', ['id', 'access', 'path', 'identifier', 'contentUrl', 'contentSize', 'digest', 'datePublished', 'publishedBy'])), _connector='OR'), name='asset_metadata_no_computed_keys_or_published'),
        ),
        migrations.AddConstraint(
            model_name='assetpath',
            constraint=models.CheckConstraint(check=models.Q(('path__endswith', '/'), ('path__startswith', '/'), _connector='OR', _negated=True), name='consistent-slash'),
        ),
        migrations.RunPython(migrate_embargoed_asset_blobs),
    ]
